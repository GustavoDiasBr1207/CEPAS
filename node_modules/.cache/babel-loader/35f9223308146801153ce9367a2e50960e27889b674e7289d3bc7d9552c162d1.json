{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\JoaoPedro\\\\Desktop\\\\CEPAS-1\\\\src\\\\contexts\\\\AuthContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { hasPermission as systemHasPermission, canAccessRoute, getPermissionErrorMessage } from '../utils/permissions';\n\n// Configuração da API\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001/api';\nexport const AuthContext = /*#__PURE__*/createContext();\nexport const AuthProvider = ({\n  children\n}) => {\n  _s();\n  const [user, setUser] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [token, setToken] = useState(localStorage.getItem('accessToken'));\n\n  // Configurar interceptador para requests (retorna JSON quando disponível; caso contrário, texto)\n  const makeAuthenticatedRequest = async (url, options = {}) => {\n    const authToken = localStorage.getItem('accessToken');\n    const headers = {\n      'Content-Type': 'application/json',\n      ...options.headers\n    };\n    if (authToken) {\n      headers.Authorization = `Bearer ${authToken}`;\n    } else {\n      throw new Error('Token de acesso requerido');\n    }\n    let response = await fetch(`${API_BASE_URL}${url}`, {\n      ...options,\n      headers\n    });\n\n    // Se token expirou, tentar renovar\n    if (response.status === 401) {\n      const refreshed = await refreshToken();\n      if (refreshed) {\n        // Tentar novamente com o novo token\n        const newToken = localStorage.getItem('accessToken');\n        headers.Authorization = `Bearer ${newToken}`;\n        const retryResponse = await fetch(`${API_BASE_URL}${url}`, {\n          ...options,\n          headers\n        });\n        if (!retryResponse.ok) {\n          // tentar extrair mensagem de erro do corpo\n          const ct = retryResponse.headers.get('content-type') || '';\n          if (ct.includes('application/json')) {\n            const errBody = await retryResponse.json().catch(() => ({}));\n            throw new Error(errBody.message || `Erro ${retryResponse.status}: ${retryResponse.statusText}`);\n          } else {\n            const errText = await retryResponse.text().catch(() => '');\n            throw new Error(errText || `Erro ${retryResponse.status}: ${retryResponse.statusText}`);\n          }\n        }\n        const ct = retryResponse.headers.get('content-type') || '';\n        if (ct.includes('application/json')) {\n          return await retryResponse.json();\n        }\n        const text = await retryResponse.text();\n        return {\n          message: text\n        };\n      } else {\n        // Se não conseguiu renovar, fazer logout\n        logout();\n        throw new Error('Sessão expirada. Faça login novamente.');\n      }\n    }\n    if (!response.ok) {\n      const ct = response.headers.get('content-type') || '';\n      if (ct.includes('application/json')) {\n        const errBody = await response.json().catch(() => ({}));\n        throw new Error(errBody.message || `Erro ${response.status}: ${response.statusText}`);\n      } else {\n        const errText = await response.text().catch(() => '');\n        throw new Error(errText || `Erro ${response.status}: ${response.statusText}`);\n      }\n    }\n\n    // OK: retornar JSON quando possível; senão, texto\n    const contentType = response.headers.get('content-type') || '';\n    if (contentType.includes('application/json')) {\n      return await response.json();\n    }\n    const text = await response.text();\n    return {\n      message: text\n    };\n  };\n\n  // Verificar usuário logado ao carregar a aplicação\n  useEffect(() => {\n    const checkAuth = async () => {\n      const storedToken = localStorage.getItem('accessToken');\n      if (storedToken) {\n        try {\n          const response = await fetch(`${API_BASE_URL}/auth/me`, {\n            headers: {\n              'Authorization': `Bearer ${storedToken}`,\n              'Content-Type': 'application/json'\n            }\n          });\n          if (response.ok) {\n            const data = await response.json();\n            setUser(data.user);\n            setToken(storedToken);\n          } else {\n            // Token inválido, remover\n            localStorage.removeItem('accessToken');\n            localStorage.removeItem('refreshToken');\n          }\n        } catch (error) {\n          console.error('Erro ao verificar autenticação:', error);\n          localStorage.removeItem('accessToken');\n          localStorage.removeItem('refreshToken');\n        }\n      }\n      setIsLoading(false);\n    };\n    checkAuth();\n  }, []);\n\n  // Função de login\n  const login = async (username, password) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/auth/login`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          username,\n          password\n        })\n      });\n      const data = await response.json();\n      if (!response.ok) {\n        throw new Error(data.message || 'Erro ao fazer login');\n      }\n\n      // Armazenar tokens\n      localStorage.setItem('accessToken', data.tokens.accessToken);\n      localStorage.setItem('refreshToken', data.tokens.refreshToken);\n      setUser(data.user);\n      setToken(data.tokens.accessToken);\n      return data;\n    } catch (error) {\n      throw error;\n    }\n  };\n\n  // Função de logout\n  const logout = async () => {\n    try {\n      const refreshTokenValue = localStorage.getItem('refreshToken');\n      const accessToken = localStorage.getItem('accessToken');\n      if (refreshTokenValue && accessToken) {\n        // Fazer logout no servidor sem usar makeAuthenticatedRequest para evitar loop\n        await fetch(`${API_BASE_URL}/auth/logout`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${accessToken}`\n          },\n          body: JSON.stringify({\n            refreshToken: refreshTokenValue\n          })\n        });\n      }\n    } catch (error) {\n      console.error('Erro ao fazer logout:', error);\n    } finally {\n      // Limpar dados locais independentemente do resultado\n      localStorage.removeItem('accessToken');\n      localStorage.removeItem('refreshToken');\n      setUser(null);\n      setToken(null);\n    }\n  };\n\n  // Função para renovar token\n  const refreshToken = async () => {\n    try {\n      const storedRefreshToken = localStorage.getItem('refreshToken');\n      if (!storedRefreshToken) {\n        return false;\n      }\n      const response = await fetch(`${API_BASE_URL}/auth/refresh`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          refreshToken: storedRefreshToken\n        })\n      });\n      if (response.ok) {\n        const data = await response.json();\n        localStorage.setItem('accessToken', data.tokens.accessToken);\n        localStorage.setItem('refreshToken', data.tokens.refreshToken);\n        setToken(data.tokens.accessToken);\n        return true;\n      } else {\n        return false;\n      }\n    } catch (error) {\n      console.error('Erro ao renovar token:', error);\n      return false;\n    }\n  };\n\n  // Verificar se usuário tem permissão por roles simples\n  const hasPermission = requiredRoles => {\n    if (!user) return false;\n    if (Array.isArray(requiredRoles)) {\n      return requiredRoles.includes(user.tipo_usuario);\n    }\n    return user.tipo_usuario === requiredRoles;\n  };\n  const value = {\n    user,\n    token,\n    isLoading,\n    login,\n    logout,\n    makeAuthenticatedRequest,\n    hasPermission,\n    isAuthenticated: !!user,\n    isAdmin: (user === null || user === void 0 ? void 0 : user.tipo_usuario) === 'admin',\n    isCoordenador: (user === null || user === void 0 ? void 0 : user.tipo_usuario) === 'coordenador',\n    isMonitor: (user === null || user === void 0 ? void 0 : user.tipo_usuario) === 'monitor',\n    isVisualizador: (user === null || user === void 0 ? void 0 : user.tipo_usuario) === 'visualizador',\n    // Novos utilitários de permissão usando o sistema atualizado\n    // Permissões de sistema baseadas em regras externas\n    hasSystemPermission: (action, resource) => systemHasPermission(user, action, resource),\n    canAccessRoute: route => canAccessRoute(user, route),\n    getPermissionErrorMessage: (action, resource) => getPermissionErrorMessage(user, action, resource),\n    // Helper para verificar se é admin com poder máximo\n    isMaxAdmin: () => (user === null || user === void 0 ? void 0 : user.tipo_usuario) === 'admin' || (user === null || user === void 0 ? void 0 : user.role) === 'admin'\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 251,\n    columnNumber: 9\n  }, this);\n};\n_s(AuthProvider, \"bBLZhaLtoDlKGNxbHZ3NYhVUqes=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","hasPermission","systemHasPermission","canAccessRoute","getPermissionErrorMessage","jsxDEV","_jsxDEV","API_BASE_URL","process","env","REACT_APP_API_BASE_URL","AuthContext","AuthProvider","children","_s","user","setUser","isLoading","setIsLoading","token","setToken","localStorage","getItem","makeAuthenticatedRequest","url","options","authToken","headers","Authorization","Error","response","fetch","status","refreshed","refreshToken","newToken","retryResponse","ok","ct","get","includes","errBody","json","catch","message","statusText","errText","text","logout","contentType","checkAuth","storedToken","data","removeItem","error","console","login","username","password","method","body","JSON","stringify","setItem","tokens","accessToken","refreshTokenValue","storedRefreshToken","requiredRoles","Array","isArray","tipo_usuario","value","isAuthenticated","isAdmin","isCoordenador","isMonitor","isVisualizador","hasSystemPermission","action","resource","route","isMaxAdmin","role","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/JoaoPedro/Desktop/CEPAS-1/src/contexts/AuthContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\r\nimport { hasPermission as systemHasPermission, canAccessRoute, getPermissionErrorMessage } from '../utils/permissions';\r\n\r\n// Configuração da API\r\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001/api';\r\n\r\nexport const AuthContext = createContext();\r\n\r\nexport const AuthProvider = ({ children }) => {\r\n    const [user, setUser] = useState(null);\r\n    const [isLoading, setIsLoading] = useState(true);\r\n    const [token, setToken] = useState(localStorage.getItem('accessToken'));\r\n\r\n    // Configurar interceptador para requests (retorna JSON quando disponível; caso contrário, texto)\r\n    const makeAuthenticatedRequest = async (url, options = {}) => {\r\n        const authToken = localStorage.getItem('accessToken');\r\n        \r\n        const headers = {\r\n            'Content-Type': 'application/json',\r\n            ...options.headers,\r\n        };\r\n\r\n        if (authToken) {\r\n            headers.Authorization = `Bearer ${authToken}`;\r\n        } else {\r\n            throw new Error('Token de acesso requerido');\r\n        }\r\n\r\n        let response = await fetch(`${API_BASE_URL}${url}`, {\r\n            ...options,\r\n            headers,\r\n        });\r\n\r\n        // Se token expirou, tentar renovar\r\n        if (response.status === 401) {\r\n            const refreshed = await refreshToken();\r\n            if (refreshed) {\r\n                // Tentar novamente com o novo token\r\n                const newToken = localStorage.getItem('accessToken');\r\n                headers.Authorization = `Bearer ${newToken}`;\r\n                const retryResponse = await fetch(`${API_BASE_URL}${url}`, {\r\n                    ...options,\r\n                    headers,\r\n                });\r\n                \r\n                if (!retryResponse.ok) {\r\n                    // tentar extrair mensagem de erro do corpo\r\n                    const ct = retryResponse.headers.get('content-type') || '';\r\n                    if (ct.includes('application/json')) {\r\n                        const errBody = await retryResponse.json().catch(() => ({}));\r\n                        throw new Error(errBody.message || `Erro ${retryResponse.status}: ${retryResponse.statusText}`);\r\n                    } else {\r\n                        const errText = await retryResponse.text().catch(() => '');\r\n                        throw new Error(errText || `Erro ${retryResponse.status}: ${retryResponse.statusText}`);\r\n                    }\r\n                }\r\n                \r\n                const ct = retryResponse.headers.get('content-type') || '';\r\n                if (ct.includes('application/json')) {\r\n                    return await retryResponse.json();\r\n                }\r\n                const text = await retryResponse.text();\r\n                return { message: text };\r\n            } else {\r\n                // Se não conseguiu renovar, fazer logout\r\n                logout();\r\n                throw new Error('Sessão expirada. Faça login novamente.');\r\n            }\r\n        }\r\n\r\n        if (!response.ok) {\r\n            const ct = response.headers.get('content-type') || '';\r\n            if (ct.includes('application/json')) {\r\n                const errBody = await response.json().catch(() => ({}));\r\n                throw new Error(errBody.message || `Erro ${response.status}: ${response.statusText}`);\r\n            } else {\r\n                const errText = await response.text().catch(() => '');\r\n                throw new Error(errText || `Erro ${response.status}: ${response.statusText}`);\r\n            }\r\n        }\r\n\r\n        // OK: retornar JSON quando possível; senão, texto\r\n        const contentType = response.headers.get('content-type') || '';\r\n        if (contentType.includes('application/json')) {\r\n            return await response.json();\r\n        }\r\n        const text = await response.text();\r\n        return { message: text };\r\n    };\r\n\r\n    // Verificar usuário logado ao carregar a aplicação\r\n    useEffect(() => {\r\n        const checkAuth = async () => {\r\n            const storedToken = localStorage.getItem('accessToken');\r\n            \r\n            if (storedToken) {\r\n                try {\r\n                    const response = await fetch(`${API_BASE_URL}/auth/me`, {\r\n                        headers: {\r\n                            'Authorization': `Bearer ${storedToken}`,\r\n                            'Content-Type': 'application/json'\r\n                        }\r\n                    });\r\n                    \r\n                    if (response.ok) {\r\n                        const data = await response.json();\r\n                        setUser(data.user);\r\n                        setToken(storedToken);\r\n                    } else {\r\n                        // Token inválido, remover\r\n                        localStorage.removeItem('accessToken');\r\n                        localStorage.removeItem('refreshToken');\r\n                    }\r\n                } catch (error) {\r\n                    console.error('Erro ao verificar autenticação:', error);\r\n                    localStorage.removeItem('accessToken');\r\n                    localStorage.removeItem('refreshToken');\r\n                }\r\n            }\r\n            \r\n            setIsLoading(false);\r\n        };\r\n\r\n        checkAuth();\r\n    }, []);\r\n\r\n    // Função de login\r\n    const login = async (username, password) => {\r\n        try {\r\n            const response = await fetch(`${API_BASE_URL}/auth/login`, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({ username, password }),\r\n            });\r\n\r\n            const data = await response.json();\r\n\r\n            if (!response.ok) {\r\n                throw new Error(data.message || 'Erro ao fazer login');\r\n            }\r\n\r\n            // Armazenar tokens\r\n            localStorage.setItem('accessToken', data.tokens.accessToken);\r\n            localStorage.setItem('refreshToken', data.tokens.refreshToken);\r\n            \r\n            setUser(data.user);\r\n            setToken(data.tokens.accessToken);\r\n\r\n            return data;\r\n        } catch (error) {\r\n            throw error;\r\n        }\r\n    };\r\n\r\n    // Função de logout\r\n    const logout = async () => {\r\n        try {\r\n            const refreshTokenValue = localStorage.getItem('refreshToken');\r\n            const accessToken = localStorage.getItem('accessToken');\r\n            \r\n            if (refreshTokenValue && accessToken) {\r\n                // Fazer logout no servidor sem usar makeAuthenticatedRequest para evitar loop\r\n                await fetch(`${API_BASE_URL}/auth/logout`, {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                        'Authorization': `Bearer ${accessToken}`\r\n                    },\r\n                    body: JSON.stringify({ refreshToken: refreshTokenValue }),\r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.error('Erro ao fazer logout:', error);\r\n        } finally {\r\n            // Limpar dados locais independentemente do resultado\r\n            localStorage.removeItem('accessToken');\r\n            localStorage.removeItem('refreshToken');\r\n            setUser(null);\r\n            setToken(null);\r\n        }\r\n    };\r\n\r\n    // Função para renovar token\r\n    const refreshToken = async () => {\r\n        try {\r\n            const storedRefreshToken = localStorage.getItem('refreshToken');\r\n            \r\n            if (!storedRefreshToken) {\r\n                return false;\r\n            }\r\n\r\n            const response = await fetch(`${API_BASE_URL}/auth/refresh`, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({ refreshToken: storedRefreshToken }),\r\n            });\r\n\r\n            if (response.ok) {\r\n                const data = await response.json();\r\n                localStorage.setItem('accessToken', data.tokens.accessToken);\r\n                localStorage.setItem('refreshToken', data.tokens.refreshToken);\r\n                setToken(data.tokens.accessToken);\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } catch (error) {\r\n            console.error('Erro ao renovar token:', error);\r\n            return false;\r\n        }\r\n    };\r\n\r\n    // Verificar se usuário tem permissão por roles simples\r\n    const hasPermission = (requiredRoles) => {\r\n        if (!user) return false;\r\n        \r\n        if (Array.isArray(requiredRoles)) {\r\n            return requiredRoles.includes(user.tipo_usuario);\r\n        }\r\n        \r\n        return user.tipo_usuario === requiredRoles;\r\n    };\r\n\r\n    const value = {\r\n        user,\r\n        token,\r\n        isLoading,\r\n        login,\r\n        logout,\r\n        makeAuthenticatedRequest,\r\n        hasPermission,\r\n        isAuthenticated: !!user,\r\n        isAdmin: user?.tipo_usuario === 'admin',\r\n        isCoordenador: user?.tipo_usuario === 'coordenador',\r\n        isMonitor: user?.tipo_usuario === 'monitor',\r\n        isVisualizador: user?.tipo_usuario === 'visualizador',\r\n        // Novos utilitários de permissão usando o sistema atualizado\r\n    // Permissões de sistema baseadas em regras externas\r\n    hasSystemPermission: (action, resource) => systemHasPermission(user, action, resource),\r\n    canAccessRoute: (route) => canAccessRoute(user, route),\r\n    getPermissionErrorMessage: (action, resource) => getPermissionErrorMessage(user, action, resource),\r\n        // Helper para verificar se é admin com poder máximo\r\n        isMaxAdmin: () => user?.tipo_usuario === 'admin' || user?.role === 'admin'\r\n    };\r\n\r\n    return (\r\n        <AuthContext.Provider value={value}>\r\n            {children}\r\n        </AuthContext.Provider>\r\n    );\r\n};"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC7E,SAASC,aAAa,IAAIC,mBAAmB,EAAEC,cAAc,EAAEC,yBAAyB,QAAQ,sBAAsB;;AAEtH;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,MAAMC,YAAY,GAAGC,OAAO,CAACC,GAAG,CAACC,sBAAsB,IAAI,2BAA2B;AAEtF,OAAO,MAAMC,WAAW,gBAAGd,aAAa,CAAC,CAAC;AAE1C,OAAO,MAAMe,YAAY,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EAC1C,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGjB,QAAQ,CAAC,IAAI,CAAC;EACtC,MAAM,CAACkB,SAAS,EAAEC,YAAY,CAAC,GAAGnB,QAAQ,CAAC,IAAI,CAAC;EAChD,MAAM,CAACoB,KAAK,EAAEC,QAAQ,CAAC,GAAGrB,QAAQ,CAACsB,YAAY,CAACC,OAAO,CAAC,aAAa,CAAC,CAAC;;EAEvE;EACA,MAAMC,wBAAwB,GAAG,MAAAA,CAAOC,GAAG,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAK;IAC1D,MAAMC,SAAS,GAAGL,YAAY,CAACC,OAAO,CAAC,aAAa,CAAC;IAErD,MAAMK,OAAO,GAAG;MACZ,cAAc,EAAE,kBAAkB;MAClC,GAAGF,OAAO,CAACE;IACf,CAAC;IAED,IAAID,SAAS,EAAE;MACXC,OAAO,CAACC,aAAa,GAAG,UAAUF,SAAS,EAAE;IACjD,CAAC,MAAM;MACH,MAAM,IAAIG,KAAK,CAAC,2BAA2B,CAAC;IAChD;IAEA,IAAIC,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGxB,YAAY,GAAGiB,GAAG,EAAE,EAAE;MAChD,GAAGC,OAAO;MACVE;IACJ,CAAC,CAAC;;IAEF;IACA,IAAIG,QAAQ,CAACE,MAAM,KAAK,GAAG,EAAE;MACzB,MAAMC,SAAS,GAAG,MAAMC,YAAY,CAAC,CAAC;MACtC,IAAID,SAAS,EAAE;QACX;QACA,MAAME,QAAQ,GAAGd,YAAY,CAACC,OAAO,CAAC,aAAa,CAAC;QACpDK,OAAO,CAACC,aAAa,GAAG,UAAUO,QAAQ,EAAE;QAC5C,MAAMC,aAAa,GAAG,MAAML,KAAK,CAAC,GAAGxB,YAAY,GAAGiB,GAAG,EAAE,EAAE;UACvD,GAAGC,OAAO;UACVE;QACJ,CAAC,CAAC;QAEF,IAAI,CAACS,aAAa,CAACC,EAAE,EAAE;UACnB;UACA,MAAMC,EAAE,GAAGF,aAAa,CAACT,OAAO,CAACY,GAAG,CAAC,cAAc,CAAC,IAAI,EAAE;UAC1D,IAAID,EAAE,CAACE,QAAQ,CAAC,kBAAkB,CAAC,EAAE;YACjC,MAAMC,OAAO,GAAG,MAAML,aAAa,CAACM,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC5D,MAAM,IAAId,KAAK,CAACY,OAAO,CAACG,OAAO,IAAI,QAAQR,aAAa,CAACJ,MAAM,KAAKI,aAAa,CAACS,UAAU,EAAE,CAAC;UACnG,CAAC,MAAM;YACH,MAAMC,OAAO,GAAG,MAAMV,aAAa,CAACW,IAAI,CAAC,CAAC,CAACJ,KAAK,CAAC,MAAM,EAAE,CAAC;YAC1D,MAAM,IAAId,KAAK,CAACiB,OAAO,IAAI,QAAQV,aAAa,CAACJ,MAAM,KAAKI,aAAa,CAACS,UAAU,EAAE,CAAC;UAC3F;QACJ;QAEA,MAAMP,EAAE,GAAGF,aAAa,CAACT,OAAO,CAACY,GAAG,CAAC,cAAc,CAAC,IAAI,EAAE;QAC1D,IAAID,EAAE,CAACE,QAAQ,CAAC,kBAAkB,CAAC,EAAE;UACjC,OAAO,MAAMJ,aAAa,CAACM,IAAI,CAAC,CAAC;QACrC;QACA,MAAMK,IAAI,GAAG,MAAMX,aAAa,CAACW,IAAI,CAAC,CAAC;QACvC,OAAO;UAAEH,OAAO,EAAEG;QAAK,CAAC;MAC5B,CAAC,MAAM;QACH;QACAC,MAAM,CAAC,CAAC;QACR,MAAM,IAAInB,KAAK,CAAC,wCAAwC,CAAC;MAC7D;IACJ;IAEA,IAAI,CAACC,QAAQ,CAACO,EAAE,EAAE;MACd,MAAMC,EAAE,GAAGR,QAAQ,CAACH,OAAO,CAACY,GAAG,CAAC,cAAc,CAAC,IAAI,EAAE;MACrD,IAAID,EAAE,CAACE,QAAQ,CAAC,kBAAkB,CAAC,EAAE;QACjC,MAAMC,OAAO,GAAG,MAAMX,QAAQ,CAACY,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACvD,MAAM,IAAId,KAAK,CAACY,OAAO,CAACG,OAAO,IAAI,QAAQd,QAAQ,CAACE,MAAM,KAAKF,QAAQ,CAACe,UAAU,EAAE,CAAC;MACzF,CAAC,MAAM;QACH,MAAMC,OAAO,GAAG,MAAMhB,QAAQ,CAACiB,IAAI,CAAC,CAAC,CAACJ,KAAK,CAAC,MAAM,EAAE,CAAC;QACrD,MAAM,IAAId,KAAK,CAACiB,OAAO,IAAI,QAAQhB,QAAQ,CAACE,MAAM,KAAKF,QAAQ,CAACe,UAAU,EAAE,CAAC;MACjF;IACJ;;IAEA;IACA,MAAMI,WAAW,GAAGnB,QAAQ,CAACH,OAAO,CAACY,GAAG,CAAC,cAAc,CAAC,IAAI,EAAE;IAC9D,IAAIU,WAAW,CAACT,QAAQ,CAAC,kBAAkB,CAAC,EAAE;MAC1C,OAAO,MAAMV,QAAQ,CAACY,IAAI,CAAC,CAAC;IAChC;IACA,MAAMK,IAAI,GAAG,MAAMjB,QAAQ,CAACiB,IAAI,CAAC,CAAC;IAClC,OAAO;MAAEH,OAAO,EAAEG;IAAK,CAAC;EAC5B,CAAC;;EAED;EACA/C,SAAS,CAAC,MAAM;IACZ,MAAMkD,SAAS,GAAG,MAAAA,CAAA,KAAY;MAC1B,MAAMC,WAAW,GAAG9B,YAAY,CAACC,OAAO,CAAC,aAAa,CAAC;MAEvD,IAAI6B,WAAW,EAAE;QACb,IAAI;UACA,MAAMrB,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGxB,YAAY,UAAU,EAAE;YACpDoB,OAAO,EAAE;cACL,eAAe,EAAE,UAAUwB,WAAW,EAAE;cACxC,cAAc,EAAE;YACpB;UACJ,CAAC,CAAC;UAEF,IAAIrB,QAAQ,CAACO,EAAE,EAAE;YACb,MAAMe,IAAI,GAAG,MAAMtB,QAAQ,CAACY,IAAI,CAAC,CAAC;YAClC1B,OAAO,CAACoC,IAAI,CAACrC,IAAI,CAAC;YAClBK,QAAQ,CAAC+B,WAAW,CAAC;UACzB,CAAC,MAAM;YACH;YACA9B,YAAY,CAACgC,UAAU,CAAC,aAAa,CAAC;YACtChC,YAAY,CAACgC,UAAU,CAAC,cAAc,CAAC;UAC3C;QACJ,CAAC,CAAC,OAAOC,KAAK,EAAE;UACZC,OAAO,CAACD,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;UACvDjC,YAAY,CAACgC,UAAU,CAAC,aAAa,CAAC;UACtChC,YAAY,CAACgC,UAAU,CAAC,cAAc,CAAC;QAC3C;MACJ;MAEAnC,YAAY,CAAC,KAAK,CAAC;IACvB,CAAC;IAEDgC,SAAS,CAAC,CAAC;EACf,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMM,KAAK,GAAG,MAAAA,CAAOC,QAAQ,EAAEC,QAAQ,KAAK;IACxC,IAAI;MACA,MAAM5B,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGxB,YAAY,aAAa,EAAE;QACvDoD,MAAM,EAAE,MAAM;QACdhC,OAAO,EAAE;UACL,cAAc,EAAE;QACpB,CAAC;QACDiC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UAAEL,QAAQ;UAAEC;QAAS,CAAC;MAC/C,CAAC,CAAC;MAEF,MAAMN,IAAI,GAAG,MAAMtB,QAAQ,CAACY,IAAI,CAAC,CAAC;MAElC,IAAI,CAACZ,QAAQ,CAACO,EAAE,EAAE;QACd,MAAM,IAAIR,KAAK,CAACuB,IAAI,CAACR,OAAO,IAAI,qBAAqB,CAAC;MAC1D;;MAEA;MACAvB,YAAY,CAAC0C,OAAO,CAAC,aAAa,EAAEX,IAAI,CAACY,MAAM,CAACC,WAAW,CAAC;MAC5D5C,YAAY,CAAC0C,OAAO,CAAC,cAAc,EAAEX,IAAI,CAACY,MAAM,CAAC9B,YAAY,CAAC;MAE9DlB,OAAO,CAACoC,IAAI,CAACrC,IAAI,CAAC;MAClBK,QAAQ,CAACgC,IAAI,CAACY,MAAM,CAACC,WAAW,CAAC;MAEjC,OAAOb,IAAI;IACf,CAAC,CAAC,OAAOE,KAAK,EAAE;MACZ,MAAMA,KAAK;IACf;EACJ,CAAC;;EAED;EACA,MAAMN,MAAM,GAAG,MAAAA,CAAA,KAAY;IACvB,IAAI;MACA,MAAMkB,iBAAiB,GAAG7C,YAAY,CAACC,OAAO,CAAC,cAAc,CAAC;MAC9D,MAAM2C,WAAW,GAAG5C,YAAY,CAACC,OAAO,CAAC,aAAa,CAAC;MAEvD,IAAI4C,iBAAiB,IAAID,WAAW,EAAE;QAClC;QACA,MAAMlC,KAAK,CAAC,GAAGxB,YAAY,cAAc,EAAE;UACvCoD,MAAM,EAAE,MAAM;UACdhC,OAAO,EAAE;YACL,cAAc,EAAE,kBAAkB;YAClC,eAAe,EAAE,UAAUsC,WAAW;UAC1C,CAAC;UACDL,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;YAAE5B,YAAY,EAAEgC;UAAkB,CAAC;QAC5D,CAAC,CAAC;MACN;IACJ,CAAC,CAAC,OAAOZ,KAAK,EAAE;MACZC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;IACjD,CAAC,SAAS;MACN;MACAjC,YAAY,CAACgC,UAAU,CAAC,aAAa,CAAC;MACtChC,YAAY,CAACgC,UAAU,CAAC,cAAc,CAAC;MACvCrC,OAAO,CAAC,IAAI,CAAC;MACbI,QAAQ,CAAC,IAAI,CAAC;IAClB;EACJ,CAAC;;EAED;EACA,MAAMc,YAAY,GAAG,MAAAA,CAAA,KAAY;IAC7B,IAAI;MACA,MAAMiC,kBAAkB,GAAG9C,YAAY,CAACC,OAAO,CAAC,cAAc,CAAC;MAE/D,IAAI,CAAC6C,kBAAkB,EAAE;QACrB,OAAO,KAAK;MAChB;MAEA,MAAMrC,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGxB,YAAY,eAAe,EAAE;QACzDoD,MAAM,EAAE,MAAM;QACdhC,OAAO,EAAE;UACL,cAAc,EAAE;QACpB,CAAC;QACDiC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UAAE5B,YAAY,EAAEiC;QAAmB,CAAC;MAC7D,CAAC,CAAC;MAEF,IAAIrC,QAAQ,CAACO,EAAE,EAAE;QACb,MAAMe,IAAI,GAAG,MAAMtB,QAAQ,CAACY,IAAI,CAAC,CAAC;QAClCrB,YAAY,CAAC0C,OAAO,CAAC,aAAa,EAAEX,IAAI,CAACY,MAAM,CAACC,WAAW,CAAC;QAC5D5C,YAAY,CAAC0C,OAAO,CAAC,cAAc,EAAEX,IAAI,CAACY,MAAM,CAAC9B,YAAY,CAAC;QAC9Dd,QAAQ,CAACgC,IAAI,CAACY,MAAM,CAACC,WAAW,CAAC;QACjC,OAAO,IAAI;MACf,CAAC,MAAM;QACH,OAAO,KAAK;MAChB;IACJ,CAAC,CAAC,OAAOX,KAAK,EAAE;MACZC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,OAAO,KAAK;IAChB;EACJ,CAAC;;EAED;EACA,MAAMrD,aAAa,GAAImE,aAAa,IAAK;IACrC,IAAI,CAACrD,IAAI,EAAE,OAAO,KAAK;IAEvB,IAAIsD,KAAK,CAACC,OAAO,CAACF,aAAa,CAAC,EAAE;MAC9B,OAAOA,aAAa,CAAC5B,QAAQ,CAACzB,IAAI,CAACwD,YAAY,CAAC;IACpD;IAEA,OAAOxD,IAAI,CAACwD,YAAY,KAAKH,aAAa;EAC9C,CAAC;EAED,MAAMI,KAAK,GAAG;IACVzD,IAAI;IACJI,KAAK;IACLF,SAAS;IACTuC,KAAK;IACLR,MAAM;IACNzB,wBAAwB;IACxBtB,aAAa;IACbwE,eAAe,EAAE,CAAC,CAAC1D,IAAI;IACvB2D,OAAO,EAAE,CAAA3D,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEwD,YAAY,MAAK,OAAO;IACvCI,aAAa,EAAE,CAAA5D,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEwD,YAAY,MAAK,aAAa;IACnDK,SAAS,EAAE,CAAA7D,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEwD,YAAY,MAAK,SAAS;IAC3CM,cAAc,EAAE,CAAA9D,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEwD,YAAY,MAAK,cAAc;IACrD;IACJ;IACAO,mBAAmB,EAAEA,CAACC,MAAM,EAAEC,QAAQ,KAAK9E,mBAAmB,CAACa,IAAI,EAAEgE,MAAM,EAAEC,QAAQ,CAAC;IACtF7E,cAAc,EAAG8E,KAAK,IAAK9E,cAAc,CAACY,IAAI,EAAEkE,KAAK,CAAC;IACtD7E,yBAAyB,EAAEA,CAAC2E,MAAM,EAAEC,QAAQ,KAAK5E,yBAAyB,CAACW,IAAI,EAAEgE,MAAM,EAAEC,QAAQ,CAAC;IAC9F;IACAE,UAAU,EAAEA,CAAA,KAAM,CAAAnE,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEwD,YAAY,MAAK,OAAO,IAAI,CAAAxD,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEoE,IAAI,MAAK;EACvE,CAAC;EAED,oBACI7E,OAAA,CAACK,WAAW,CAACyE,QAAQ;IAACZ,KAAK,EAAEA,KAAM;IAAA3D,QAAA,EAC9BA;EAAQ;IAAAwE,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACS,CAAC;AAE/B,CAAC;AAAC1E,EAAA,CAtPWF,YAAY;AAAA6E,EAAA,GAAZ7E,YAAY;AAAA,IAAA6E,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}